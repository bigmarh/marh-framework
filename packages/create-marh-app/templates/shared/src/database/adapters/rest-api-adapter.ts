/**
 * REST API Database Adapter
 * 
 * Connects to RESTful API backends using standard HTTP methods.
 * Maps database operations to REST endpoints with configurable conventions.
 */

import { 
  BaseDatabaseAdapter, 
  BaseDatabase, 
  BaseTable, 
  BaseQueryBuilder 
} from './base-adapter';
import { 
  IDatabase, 
  ITable, 
  IQueryBuilder,
  DatabaseConfig, 
  TableSchema, 
  Migration,
  QueryResult,
  QueryContext,
  ConnectionError,
  QueryError
} from '../database.interface';
import { BaseEntity, QueryOptions, PaginatedResult } from '../../services/crud.interface';

/**
 * REST API configuration options
 */
interface RestApiOptions {\n  baseUrl: string;\n  headers?: Record<string, string>;\n  timeout?: number;\n  retries?: number;\n  endpoints?: {\n    // Custom endpoint patterns\n    list?: string;      // GET /api/users\n    create?: string;    // POST /api/users\n    read?: string;      // GET /api/users/:id\n    update?: string;    // PUT /api/users/:id\n    delete?: string;    // DELETE /api/users/:id\n    query?: string;     // POST /api/users/query\n  };\n  conventions?: {\n    // API conventions\n    idField?: string;           // 'id' | '_id' | 'uuid'\n    timestampFields?: {\n      created?: string;         // 'createdAt' | 'created_at'\n      updated?: string;         // 'updatedAt' | 'updated_at'\n    };\n    paginationStyle?: 'offset' | 'cursor' | 'page';  \n    responseWrapper?: string;   // 'data' | 'results' | null\n    errorField?: string;        // 'error' | 'message'\n  };\n}\n\n/**\n * HTTP client for API requests\n */\nclass ApiClient {\n  constructor(private options: RestApiOptions) {}\n\n  async request<T = any>(\n    method: 'GET' | 'POST' | 'PUT' | 'DELETE',\n    url: string,\n    data?: any,\n    params?: Record<string, any>\n  ): Promise<T> {\n    const fullUrl = this.buildUrl(url, params);\n    const config: RequestInit = {\n      method,\n      headers: {\n        'Content-Type': 'application/json',\n        ...this.options.headers\n      }\n    };\n\n    if (data && (method === 'POST' || method === 'PUT')) {\n      config.body = JSON.stringify(data);\n    }\n\n    // Add timeout if specified\n    if (this.options.timeout) {\n      const controller = new AbortController();\n      config.signal = controller.signal;\n      setTimeout(() => controller.abort(), this.options.timeout!);\n    }\n\n    const maxRetries = this.options.retries || 0;\n    let lastError: Error;\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        const response = await fetch(fullUrl, config);\n        \n        if (!response.ok) {\n          const error = await this.handleErrorResponse(response);\n          throw error;\n        }\n\n        const result = await response.json();\n        return this.unwrapResponse(result);\n      } catch (error: any) {\n        lastError = error;\n        \n        if (attempt < maxRetries && this.shouldRetry(error)) {\n          await this.delay(Math.pow(2, attempt) * 1000); // Exponential backoff\n          continue;\n        }\n        \n        throw error;\n      }\n    }\n\n    throw lastError!;\n  }\n\n  private buildUrl(endpoint: string, params?: Record<string, any>): string {\n    let url = `${this.options.baseUrl}${endpoint}`;\n    \n    if (params) {\n      const searchParams = new URLSearchParams();\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          searchParams.append(key, String(value));\n        }\n      });\n      \n      if (searchParams.toString()) {\n        url += `?${searchParams.toString()}`;\n      }\n    }\n    \n    return url;\n  }\n\n  private async handleErrorResponse(response: Response): Promise<Error> {\n    try {\n      const errorData = await response.json();\n      const errorField = this.options.conventions?.errorField || 'message';\n      const message = errorData[errorField] || errorData.error || `HTTP ${response.status}: ${response.statusText}`;\n      \n      if (response.status >= 500) {\n        return new ConnectionError(message);\n      } else {\n        return new QueryError(message);\n      }\n    } catch {\n      return new QueryError(`HTTP ${response.status}: ${response.statusText}`);\n    }\n  }\n\n  private unwrapResponse(response: any): any {\n    const wrapper = this.options.conventions?.responseWrapper;\n    return wrapper && response[wrapper] !== undefined ? response[wrapper] : response;\n  }\n\n  private shouldRetry(error: Error): boolean {\n    return error instanceof ConnectionError || \n           (error as any).name === 'AbortError' ||\n           (error instanceof QueryError && (error as any).code >= 500);\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\n/**\n * REST API Query Builder\n */\nclass RestApiQueryBuilder<T extends BaseEntity> extends BaseQueryBuilder<T> {\n  constructor(\n    tableName: string,\n    private table: RestApiTable<T>\n  ) {\n    super(tableName);\n  }\n\n  async first(): Promise<T | null> {\n    this._limit = 1;\n    const results = await this.get();\n    return results[0] || null;\n  }\n\n  async get(): Promise<T[]> {\n    const queryParams = this.buildQueryParams();\n    const endpoint = this.table.getEndpoint('query') || this.table.getEndpoint('list');\n    \n    if (this.table.getEndpoint('query')) {\n      // Use POST for complex queries\n      return this.table.apiClient.request('POST', endpoint!, queryParams);\n    } else {\n      // Use GET with query params\n      return this.table.apiClient.request('GET', endpoint!, undefined, queryParams);\n    }\n  }\n\n  async paginate(page: number, limit: number): Promise<PaginatedResult<T>> {\n    const queryParams = {\n      ...this.buildQueryParams(),\n      page,\n      limit\n    };\n    \n    const endpoint = this.table.getEndpoint('query') || this.table.getEndpoint('list');\n    const result = await this.table.apiClient.request(\n      this.table.getEndpoint('query') ? 'POST' : 'GET',\n      endpoint!,\n      this.table.getEndpoint('query') ? queryParams : undefined,\n      this.table.getEndpoint('query') ? undefined : queryParams\n    );\n    \n    // Handle different pagination response formats\n    if (result.data && result.pagination) {\n      return {\n        data: result.data,\n        total: result.pagination.total,\n        page: result.pagination.page,\n        limit: result.pagination.limit,\n        pages: result.pagination.pages\n      };\n    } else if (Array.isArray(result)) {\n      return {\n        data: result,\n        total: result.length,\n        page,\n        limit,\n        pages: 1\n      };\n    } else {\n      return result;\n    }\n  }\n\n  async count(): Promise<number> {\n    const queryParams = {\n      ...this.buildQueryParams(),\n      _count: true\n    };\n    \n    const endpoint = this.table.getEndpoint('query') || this.table.getEndpoint('list');\n    const result = await this.table.apiClient.request(\n      this.table.getEndpoint('query') ? 'POST' : 'GET',\n      endpoint!,\n      this.table.getEndpoint('query') ? queryParams : undefined,\n      this.table.getEndpoint('query') ? undefined : queryParams\n    );\n    \n    return typeof result === 'number' ? result : result.count || 0;\n  }\n\n  async update(data: Partial<T>): Promise<number> {\n    const queryParams = this.buildQueryParams();\n    const endpoint = `${this.table.getEndpoint('list')}/bulk-update`;\n    \n    const result = await this.table.apiClient.request('PUT', endpoint, {\n      filter: queryParams,\n      data\n    });\n    \n    return result.updated || result.count || 0;\n  }\n\n  async delete(): Promise<number> {\n    const queryParams = this.buildQueryParams();\n    const endpoint = `${this.table.getEndpoint('list')}/bulk-delete`;\n    \n    const result = await this.table.apiClient.request('DELETE', endpoint, queryParams);\n    return result.deleted || result.count || 0;\n  }\n\n  toSql(): { query: string; bindings: any[] } {\n    const params = this.buildQueryParams();\n    return {\n      query: `REST API Query: ${JSON.stringify(params)}`,\n      bindings: []\n    };\n  }\n\n  private buildQueryParams(): any {\n    const params: any = {};\n    \n    // Add where conditions\n    if (this._where.length > 0) {\n      params.filter = {};\n      this._where.forEach(condition => {\n        params.filter[condition.field] = {\n          [condition.operator]: condition.value\n        };\n      });\n    }\n    \n    // Add sorting\n    if (this._orderBy.length > 0) {\n      params.sort = this._orderBy.map(sort => ({\n        field: sort.field,\n        direction: sort.direction\n      }));\n    }\n    \n    // Add field selection\n    if (this._select && !this._select.includes('*')) {\n      params.fields = this._select;\n    }\n    \n    // Add pagination\n    if (this._limit) {\n      params.limit = this._limit;\n    }\n    if (this._offset) {\n      params.offset = this._offset;\n    }\n    \n    return params;\n  }\n}\n\n/**\n * REST API Table Implementation\n */\nclass RestApiTable<T extends BaseEntity> extends BaseTable<T> {\n  public apiClient: ApiClient;\n  private endpoints: Record<string, string>;\n\n  constructor(\n    name: string,\n    database: RestApiDatabase,\n    private options: RestApiOptions\n  ) {\n    super(name, database);\n    this.apiClient = new ApiClient(options);\n    this.endpoints = this.buildEndpoints();\n  }\n\n  getEndpoint(operation: string): string {\n    return this.endpoints[operation];\n  }\n\n  async create(data: Omit<T, 'id' | 'createdAt' | 'updatedAt'>): Promise<T> {\n    const endpoint = this.getEndpoint('create');\n    return this.apiClient.request('POST', endpoint, data);\n  }\n\n  async findById(id: string | number): Promise<T | null> {\n    try {\n      const endpoint = this.getEndpoint('read').replace(':id', String(id));\n      return await this.apiClient.request('GET', endpoint);\n    } catch (error: any) {\n      if (error instanceof QueryError && error.message.includes('404')) {\n        return null;\n      }\n      throw error;\n    }\n  }\n\n  async findOne(filter: Partial<T>): Promise<T | null> {\n    const results = await this.findMany({ filter, pagination: { page: 1, limit: 1 } });\n    return results[0] || null;\n  }\n\n  async findMany(options?: QueryOptions): Promise<T[]> {\n    const params: any = {};\n    \n    if (options?.filter) {\n      params.filter = options.filter;\n    }\n    \n    if (options?.sort) {\n      params.sort = [options.sort];\n    }\n    \n    if (options?.pagination) {\n      params.page = options.pagination.page;\n      params.limit = options.pagination.limit;\n    }\n    \n    if (options?.fields) {\n      params.fields = options.fields;\n    }\n    \n    const endpoint = this.getEndpoint('list');\n    return this.apiClient.request('GET', endpoint, undefined, params);\n  }\n\n  async findPaginated(options?: QueryOptions): Promise<PaginatedResult<T>> {\n    const pagination = options?.pagination || { page: 1, limit: 20 };\n    const params: any = {\n      page: pagination.page,\n      limit: pagination.limit\n    };\n    \n    if (options?.filter) params.filter = options.filter;\n    if (options?.sort) params.sort = [options.sort];\n    if (options?.fields) params.fields = options.fields;\n    \n    const endpoint = this.getEndpoint('list');\n    return this.apiClient.request('GET', endpoint, undefined, params);\n  }\n\n  async update(id: string | number, data: Partial<Omit<T, 'id' | 'createdAt' | 'updatedAt'>>): Promise<T> {\n    const endpoint = this.getEndpoint('update').replace(':id', String(id));\n    return this.apiClient.request('PUT', endpoint, data);\n  }\n\n  async delete(id: string | number): Promise<boolean> {\n    try {\n      const endpoint = this.getEndpoint('delete').replace(':id', String(id));\n      await this.apiClient.request('DELETE', endpoint);\n      return true;\n    } catch (error: any) {\n      if (error instanceof QueryError && error.message.includes('404')) {\n        return false;\n      }\n      throw error;\n    }\n  }\n\n  query(): IQueryBuilder<T> {\n    return new RestApiQueryBuilder(this.name, this);\n  }\n\n  async raw(sql: string, bindings?: any[]): Promise<QueryResult<T>> {\n    // Execute custom API call\n    const endpoint = `/api/query`;\n    const result = await this.apiClient.request('POST', endpoint, {\n      query: sql,\n      bindings\n    });\n    \n    return {\n      rows: Array.isArray(result) ? result : [result],\n      rowCount: Array.isArray(result) ? result.length : 1,\n      command: sql\n    };\n  }\n\n  private buildEndpoints(): Record<string, string> {\n    const tablePath = `/api/${this.name}`;\n    \n    return {\n      list: this.options.endpoints?.list || tablePath,\n      create: this.options.endpoints?.create || tablePath,\n      read: this.options.endpoints?.read || `${tablePath}/:id`,\n      update: this.options.endpoints?.update || `${tablePath}/:id`,\n      delete: this.options.endpoints?.delete || `${tablePath}/:id`,\n      query: this.options.endpoints?.query || `${tablePath}/query`\n    };\n  }\n}\n\n/**\n * REST API Database Implementation\n */\nclass RestApiDatabase extends BaseDatabase {\n  private apiClient: ApiClient;\n  private tableInstances: Map<string, RestApiTable<any>> = new Map();\n\n  constructor(config: DatabaseConfig) {\n    super(config);\n    this.apiClient = new ApiClient(config.options as RestApiOptions);\n  }\n\n  async connect(): Promise<void> {\n    if (this._isConnected) return;\n    \n    try {\n      // Test connection with a simple API call\n      const options = this.config.options as RestApiOptions;\n      await this.apiClient.request('GET', '/api/health');\n      \n      console.log(`Connected to REST API: ${options.baseUrl}`);\n      this._isConnected = true;\n      this.emit('connected', { config: this.config });\n    } catch (error) {\n      throw new ConnectionError(`Failed to connect to REST API: ${error}`);\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    if (!this._isConnected) return;\n    \n    console.log(`Disconnected from REST API`);\n    this._isConnected = false;\n    this.emit('disconnected', { config: this.config });\n  }\n\n  table<T extends BaseEntity>(name: string): ITable<T> {\n    if (!this.tableInstances.has(name)) {\n      const table = new RestApiTable<T>(name, this, this.config.options as RestApiOptions);\n      this.tableInstances.set(name, table);\n    }\n    return this.tableInstances.get(name)!;\n  }\n\n  async hasTable(name: string): Promise<boolean> {\n    try {\n      const endpoint = `/api/${name}/schema`;\n      await this.apiClient.request('GET', endpoint);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async createTable(schema: TableSchema): Promise<void> {\n    const endpoint = `/api/schema/tables`;\n    await this.apiClient.request('POST', endpoint, schema);\n  }\n\n  async dropTable(name: string): Promise<void> {\n    const endpoint = `/api/schema/tables/${name}`;\n    await this.apiClient.request('DELETE', endpoint);\n    this.tableInstances.delete(name);\n  }\n\n  async getSchema(): Promise<TableSchema[]> {\n    const endpoint = `/api/schema/tables`;\n    return this.apiClient.request('GET', endpoint);\n  }\n\n  async raw<T = any>(query: string, bindings?: any[]): Promise<QueryResult<T>> {\n    const endpoint = `/api/query`;\n    const result = await this.apiClient.request('POST', endpoint, {\n      query,\n      bindings\n    });\n    \n    return {\n      rows: Array.isArray(result) ? result : [result],\n      rowCount: Array.isArray(result) ? result.length : 1,\n      command: query\n    };\n  }\n\n  async backup(): Promise<string> {\n    const endpoint = `/api/backup`;\n    return this.apiClient.request('POST', endpoint);\n  }\n\n  async restore(backupData: string): Promise<void> {\n    const endpoint = `/api/restore`;\n    await this.apiClient.request('POST', endpoint, { data: backupData });\n  }\n\n  async analyze(): Promise<{ tables: Array<{ name: string; rowCount: number; size: string }> }> {\n    const endpoint = `/api/analyze`;\n    return this.apiClient.request('GET', endpoint);\n  }\n}\n\n/**\n * REST API Database Adapter\n */\nexport class RestApiDatabaseAdapter extends BaseDatabaseAdapter {\n  constructor() {\n    super('rest-api', ['desktop', 'pwa', 'web']);\n  }\n\n  createDatabase(config: DatabaseConfig): IDatabase {\n    return new RestApiDatabase(config);\n  }\n\n  validateConfig(config: DatabaseConfig): { valid: boolean; errors: string[] } {\n    const result = super.validateConfig(config);\n    \n    if (config.type !== 'rest-api') {\n      result.errors.push('Invalid database type for REST API adapter');\n    }\n    \n    const options = config.options as RestApiOptions;\n    if (!options?.baseUrl) {\n      result.errors.push('baseUrl is required for REST API adapter');\n    }\n    \n    if (options?.baseUrl && !options.baseUrl.startsWith('http')) {\n      result.errors.push('baseUrl must be a valid HTTP(S) URL');\n    }\n    \n    return {\n      valid: result.errors.length === 0,\n      errors: result.errors\n    };\n  }\n\n  getDefaultConfig(): Partial<DatabaseConfig> {\n    return {\n      ...super.getDefaultConfig(),\n      autoMigrate: false,\n      debug: false,\n      options: {\n        timeout: 10000,\n        retries: 3,\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        conventions: {\n          idField: 'id',\n          timestampFields: {\n            created: 'createdAt',\n            updated: 'updatedAt'\n          },\n          paginationStyle: 'offset',\n          responseWrapper: null,\n          errorField: 'message'\n        }\n      }\n    };\n  }\n}"